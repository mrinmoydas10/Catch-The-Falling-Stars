<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Stars</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a2a3a; /* Darker, more atmospheric background */
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Verdana', 'Geneva', 'Tahoma', sans-serif; /* Minimalist & common font */
            color: #ecf0f1; /* Light text color */
            flex-direction: column;
        }

        /* Basic styling for the canvas border to make it stand out */
        canvas {
            background-color: #0d1a26; /* Even darker blue for canvas background */
            border: 5px solid #4a90e2; /* Softer blue border */
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.9); /* Enhanced glow effect */
            border-radius: 8px; /* Slightly rounded corners */
        }

        #game-info {
            position: absolute;
            top: 25px; /* Slightly lower to accommodate font change */
            width: 800px;
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            font-size: 1.4em; /* Slightly smaller for minimalism */
            color: #f1c40f; /* Yellow for score/timer */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            pointer-events: none; /* Allow clicks to pass through */
            font-weight: bold; /* Make text a bit bolder */
        }

        #lifelines-display {
            color: #e74c3c; /* Red for lifelines */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }

        .screen-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); /* Slightly less transparent */
            padding: 40px 60px; /* More padding */
            border-radius: 18px; /* More rounded corners */
            text-align: center;
            color: #ecf0f1;
            font-size: 1.8em; /* Slightly smaller main text */
            box-shadow: 0 0 40px rgba(52, 152, 219, 0.8); /* Stronger glow for overlays */
            z-index: 10;
            display: flex; /* Use flexbox for consistent layout */
            flex-direction: column;
            gap: 25px; /* More space between elements */
        }

        .screen-overlay h2 {
            margin-bottom: 15px; /* Less margin at the bottom */
            color: #e74c3c; /* Red for Game Over */
            font-size: 1.5em; /* Main heading size */
        }

        #final-score {
            font-size: 1.3em; /* Slightly smaller final score */
            margin-bottom: 25px;
            color: #f1c40f;
            font-weight: bold;
        }

        .game-btn {
            background-color: #28a745; /* Bootstrap-like green */
            color: white;
            border: none;
            padding: 14px 28px; /* Slightly more padding */
            font-size: 1.1em; /* Slightly smaller font for buttons */
            border-radius: 6px; /* Smoother buttons */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin: 8px; /* More margin between buttons */
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Subtle shadow */
        }

        .game-btn:hover {
            background-color: #218838; /* Darker green on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }

        .game-btn:active {
            transform: translateY(0); /* Return to original position */
            box-shadow: 0 2px 3px rgba(0,0,0,0.2); /* Smaller shadow on active */
        }

        #start-screen {
            display: flex; /* Shown by default */
        }

        #game-duration-input {
            padding: 12px;
            font-size: 1.1em;
            border-radius: 6px;
            border: 1px solid #4a90e2;
            background-color: #2c3e50;
            color: #ecf0f1;
            width: 120px; /* Slightly wider input */
            text-align: center;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); /* Inner shadow */
        }

        .input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Space between input and checkbox */
            margin-bottom: 20px;
        }

        .input-group label {
            font-size: 1em; /* Smaller label for options */
        }

        .input-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        #copyright {
            margin-top: 25px; /* More space above the copyright text */
            font-size: 0.75em; /* Even smaller font size */
            color: #95a5a6; /* Slightly darker grey color */
        }
    </style>
</head>
<body>
    <div id="game-info">
        <div id="score">SCORE: 0</div>
        <div id="lifelines-display">LIFELINES: 2</div>
        <div id="timer">TIME: 0</div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="start-screen" class="screen-overlay">
        <h2>Falling Stars</h2>
        <div class="input-group">
            <label for="game-duration-input">Game Duration (seconds):</label>
            <input type="number" id="game-duration-input" value="60" min="10" max="300">
        </div>
        <div class="input-group">
            <input type="checkbox" id="limitless-time-checkbox">
            <label for="limitless-time-checkbox">Limitless Time</label>
        </div>
        <button id="start-game-btn" class="game-btn">Start Game</button>
    </div>

    <div id="game-over-screen" class="screen-overlay" style="display: none;">
        <h2 id="game-over-message">GAME OVER!</h2>
        <div id="final-score">Your Score: 0</div>
        <div>
            <button id="play-again-btn" class="game-btn">Play Again</button>
            <button id="retry-btn" class="game-btn">Retry</button>
        </div>
    </div>

    <div id="copyright">
        <small>All rights reserved by Mrinmoy Das</small>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const timerDisplay = document.getElementById('timer');
        const lifelinesDisplay = document.getElementById('lifelines-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameOverMessage = document.getElementById('game-over-message');
        const finalScoreDisplay = document.getElementById('final-score');
        const playAgainBtn = document.getElementById('play-again-btn');
        const retryBtn = document.getElementById('retry-btn');
        const startScreen = document.getElementById('start-screen');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameDurationInput = document.getElementById('game-duration-input');
        const limitlessTimeCheckbox = document.getElementById('limitless-time-checkbox');

        // Game state variables
        let score = 0;
        let initialGameDuration = 60; // Default, can be overridden by user
        let timeLeft = initialGameDuration;
        let isLimitlessTime = false; // New variable for limitless mode
        const maxLifelines = 2; // Fixed number of lifelines
        let currentLifelines = maxLifelines;
        let gameRunning = false;
        let gameInterval;
        let starSpawnInterval;
        let lifelineSpawnInterval; // New interval for lifelines
        let stars = [];
        let lifelines = []; // Array to hold falling lifelines

        // Basket properties
        const basket = {
            width: 120,
            height: 25,
            x: (canvas.width / 2) - 60, // Centered initially
            y: canvas.height - 40, // A bit from the bottom
            speed: 8
        };

        // Star properties
        const starMinRadius = 10;
        const starMaxRadius = 15;
        const starSpeed = 3; // Initial star falling speed

        // Lifeline properties
        const lifelineSize = 25; // Size of the heart icon
        const lifelineSpeed = 2.5; // Slightly slower than stars
        const lifelineSpawnRate = 15000; // Spawn a lifeline every 15 seconds (much rarer)

        // Game difficulty
        let currentStarSpawnRate = 1000; // Milliseconds per star (starts at 1 star/sec)
        const minSpawnRate = 300; // Fastest minimum spawn rate for challenge
        const spawnRateDecreaseStep = 30; // How much to decrease spawn rate over time
        const difficultyIncreaseInterval = 10; // Increase difficulty every X seconds

        // Input handling
        let keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Toggle visibility of duration input based on limitless checkbox
        limitlessTimeCheckbox.addEventListener('change', () => {
            gameDurationInput.disabled = limitlessTimeCheckbox.checked;
            gameDurationInput.style.opacity = limitlessTimeCheckbox.checked ? '0.5' : '1';
        });


        // --- Drawing Functions ---

        function drawBasket() {
            ctx.fillStyle = '#8B4513'; // Brown
            ctx.fillRect(basket.x, basket.y, basket.width, basket.height);
        }

        function drawStar(star) {
            ctx.fillStyle = '#FFFF00'; // Yellow
            ctx.strokeStyle = '#FFD700'; // Gold outline
            ctx.lineWidth = 2;

            const x = star.x;
            const y = star.y;
            const outerRadius = star.radius;
            const innerRadius = outerRadius / 2.5; // Inner points are smaller
            const numPoints = 5;

            ctx.beginPath();
            for (let i = 0; i < numPoints * 2; i++) {
                const angle = Math.PI / numPoints * i;
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const currentX = x + Math.cos(angle - Math.PI / 2) * r; // Adjust angle for upright star
                const currentY = y + Math.sin(angle - Math.PI / 2) * r;
                if (i === 0) {
                    ctx.moveTo(currentX, currentY);
                } else {
                    ctx.lineTo(currentX, currentY);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawHeart(heart) {
            ctx.fillStyle = '#e74c3c'; // Red for heart
            ctx.beginPath();
            const x = heart.x;
            const y = heart.y;
            const size = heart.size;

            ctx.moveTo(x, y + size / 4);
            ctx.quadraticCurveTo(x + size / 2, y - size / 2, x + size, y + size / 4);
            ctx.quadraticCurveTo(x + size, y + size, x, y + size);
            ctx.quadraticCurveTo(x - size, y + size, x - size, y + size / 4);
            ctx.quadraticCurveTo(x - size / 2, y - size / 2, x, y + size / 4);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#c0392b'; // Darker red outline
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawBackground() {
            ctx.fillStyle = '#0d1a26'; // Deep dark blue
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // --- Game Logic Functions ---

        function updateBasket() {
            if (keys['ArrowLeft'] || keys['a']) {
                basket.x -= basket.speed;
            }
            if (keys['ArrowRight'] || keys['d']) {
                basket.x += basket.speed;
            }

            // Keep basket within canvas bounds
            if (basket.x < 0) {
                basket.x = 0;
            }
            if (basket.x + basket.width > canvas.width) {
                basket.x = canvas.width - basket.width;
            }
        }

        function spawnStar() {
            const radius = starMinRadius + Math.random() * (starMaxRadius - starMinRadius);
            const x = Math.random() * (canvas.width - radius * 2) + radius; // Ensure star spawns fully within width
            stars.push({
                type: 'star', // Added type for differentiation
                x: x,
                y: -radius, // Start above canvas
                radius: radius,
                speed: starSpeed
            });
        }

        function spawnLifeline() {
            const x = Math.random() * (canvas.width - lifelineSize);
            lifelines.push({
                type: 'lifeline', // Added type for differentiation
                x: x,
                y: -lifelineSize,
                size: lifelineSize,
                speed: lifelineSpeed
            });
        }

        function updateFallingObjects() {
            // Update Stars
            for (let i = 0; i < stars.length; i++) {
                stars[i].y += stars[i].speed;

                // Collision detection with basket for stars
                if (
                    stars[i].y + stars[i].radius > basket.y &&
                    stars[i].y - stars[i].radius < basket.y + basket.height &&
                    stars[i].x + stars[i].radius > basket.x &&
                    stars[i].x - stars[i].radius < basket.x + basket.width
                ) {
                    score++;
                    scoreDisplay.textContent = `SCORE: ${score}`;
                    stars.splice(i, 1);
                    i--;
                } else if (stars[i].y - stars[i].radius > canvas.height) {
                    // Star went off screen (missed)
                    currentLifelines--;
                    lifelinesDisplay.textContent = `LIFELINES: ${currentLifelines}`;
                    stars.splice(i, 1);
                    i--;

                    if (currentLifelines <= 0) {
                        endGame("You ran out of lifelines!");
                    }
                }
            }

            // Update Lifelines
            for (let i = 0; i < lifelines.length; i++) {
                lifelines[i].y += lifelines[i].speed;

                // Collision detection with basket for lifelines
                if (
                    lifelines[i].y + lifelines[i].size > basket.y &&
                    lifelines[i].y < basket.y + basket.height && // Top of lifeline within basket height
                    lifelines[i].x + lifelines[i].size > basket.x &&
                    lifelines[i].x < basket.x + basket.width // Left of lifeline within basket width
                ) {
                    if (currentLifelines < maxLifelines) { // Only increase if not at max
                        currentLifelines++;
                        lifelinesDisplay.textContent = `LIFELINES: ${currentLifelines}`;
                    }
                    lifelines.splice(i, 1); // Remove caught lifeline
                    i--;
                } else if (lifelines[i].y > canvas.height) {
                    // Lifeline went off screen (missed)
                    lifelines.splice(i, 1);
                    i--;
                }
            }
        }

        function gameLoop() {
            if (!gameRunning) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            // Update game elements
            updateBasket();
            updateFallingObjects(); // Combined update for stars and lifelines

            // Draw game elements
            stars.forEach(star => drawStar(star));
            lifelines.forEach(lifeline => drawHeart(lifeline)); // Draw lifelines
            drawBasket();

            // Request next frame
            requestAnimationFrame(gameLoop);
        }

        function startGame(isRetry = false) {
            isLimitlessTime = limitlessTimeCheckbox.checked;

            // Only get duration from input if it's a new game and not limitless
            if (!isRetry && !isLimitlessTime) {
                const duration = parseInt(gameDurationInput.value);
                if (isNaN(duration) || duration < 10) {
                    alert("Please enter a valid game duration (minimum 10 seconds).");
                    return;
                }
                initialGameDuration = duration;
            } else if (isLimitlessTime) {
                timeLeft = 0; // Start counting up from 0 for limitless
            }

            score = 0;
            currentLifelines = maxLifelines; // Reset lifelines
            stars = [];
            lifelines = []; // Clear falling lifelines
            gameRunning = true;
            currentStarSpawnRate = 1000; // Reset spawn rate
            
            // Reset basket position for a fresh start
            basket.x = (canvas.width / 2) - (basket.width / 2);

            scoreDisplay.textContent = `SCORE: ${score}`;
            lifelinesDisplay.textContent = `LIFELINES: ${currentLifelines}`;
            timerDisplay.textContent = `TIME: ${isLimitlessTime ? '00:00' : timeLeft}`; // Initial display
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'none'; // Hide start screen

            // Clear any existing intervals
            if (gameInterval) clearInterval(gameInterval);
            if (starSpawnInterval) clearInterval(starSpawnInterval);
            if (lifelineSpawnInterval) clearInterval(lifelineSpawnInterval);


            // Start game timer
            gameInterval = setInterval(() => {
                if (isLimitlessTime) {
                    timeLeft++; // Count up
                    const minutes = Math.floor(timeLeft / 60).toString().padStart(2, '0');
                    const seconds = (timeLeft % 60).toString().padStart(2, '0');
                    timerDisplay.textContent = `TIME: ${minutes}:${seconds}`;
                } else {
                    timeLeft--; // Count down
                    timerDisplay.textContent = `TIME: ${timeLeft}`;
                    if (timeLeft <= 0) {
                        endGame("Time's Up!");
                    }
                }

                // Increase difficulty by decreasing spawn rate based on time passed (if not limitless)
                if (!isLimitlessTime && timeLeft > 0) { // Apply difficulty only in timed mode
                    const timePassed = initialGameDuration - timeLeft;
                    if (timePassed > 0 && timePassed % difficultyIncreaseInterval === 0 && currentStarSpawnRate > minSpawnRate) {
                        currentStarSpawnRate = Math.max(minSpawnRate, currentStarSpawnRate - spawnRateDecreaseStep);
                        clearInterval(starSpawnInterval); // Clear old interval
                        starSpawnInterval = setInterval(spawnStar, currentStarSpawnRate); // Start new, faster interval
                    }
                }
                // In limitless mode, difficulty could scale indefinitely with time passed (timeLeft)
                else if (isLimitlessTime && timeLeft % difficultyIncreaseInterval === 0 && currentStarSpawnRate > minSpawnRate) {
                     currentStarSpawnRate = Math.max(minSpawnRate, currentStarSpawnRate - spawnRateDecreaseStep);
                     clearInterval(starSpawnInterval); // Clear old interval
                     starSpawnInterval = setInterval(spawnStar, currentStarSpawnRate); // Start new, faster interval
                }

            }, 1000);

            // Start star spawning
            starSpawnInterval = setInterval(spawnStar, currentStarSpawnRate);

            // Start lifeline spawning
            lifelineSpawnInterval = setInterval(spawnLifeline, lifelineSpawnRate);


            // Start the animation loop
            requestAnimationFrame(gameLoop);
        }

        function endGame(message) {
            gameRunning = false;
            clearInterval(gameInterval);
            clearInterval(starSpawnInterval);
            clearInterval(lifelineSpawnInterval); // Clear lifeline interval too
            gameOverScreen.style.display = 'flex';
            gameOverMessage.textContent = message; // Set dynamic game over message
            finalScoreDisplay.textContent = `Your Score: ${score}`;
            
            // Ensure timer displays correct final time
            if (!isLimitlessTime && timeLeft < 0) timeLeft = 0;
            if (isLimitlessTime) { // Format for limitless time
                const minutes = Math.floor(timeLeft / 60).toString().padStart(2, '0');
                const seconds = (timeLeft % 60).toString().padStart(2, '0');
                timerDisplay.textContent = `TIME: ${minutes}:${seconds}`;
            } else {
                timerDisplay.textContent = `TIME: ${timeLeft}`;
            }
        }

        // Event listeners
        startGameBtn.addEventListener('click', () => startGame(false)); // Start new game
        playAgainBtn.addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex'; // Show start screen for new game setup
        });
        retryBtn.addEventListener('click', () => {
            startGame(true); // Retry game, maintaining initial duration/limitless setting
        });

        // Initial setup on page load: show the start screen
        // No call to startGame() here, as the user will initiate it
    </script>
</body>
</html>